// Backend/controllers/authController.js
const db = require('../config/db');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');
cexpexports.recuperarPassword = async (req, res) => {
  console.log('NUEVA FUNCION DE RECUPERACION EJECUTANDOSE');
  console.log('recuperarPassword llamado con:', req.body);
  const { correo, numero_documento } = req.body;.recuperarPassword = async (req, res) => {
  console.log('üö® NUEVA FUNCI√ìN DE RECUPERACI√ìN EJECUT√ÅNDOSE üö®');
  console.log('üîç recuperarPassword llamado con:', req.body);
  const { correo, numero_documento } = req.body; emailService = require('../services/emailService');

/**
 * POST /api/auth/register
 * body: { nombre, apellido, tipo_documento, numero_documento, correo, password,
 *         telefono, direccion, fecha_nacimiento, acepta_politica, rol?, avatar_url? }
 * Nota: roles v√°lidos en BD: 'paciente','odontologo','admin'
 */
exports.registerUser = async (req, res) => {
  const {
    nombre, apellido, tipo_documento, numero_documento, correo, password,
    telefono, direccion, fecha_nacimiento, acepta_politica, rol, avatar_url
  } = req.body;

  if (!nombre || !apellido || !tipo_documento || !numero_documento || !correo ||
      !password || !telefono || !direccion || !fecha_nacimiento) {
    return res.status(400).json({ msg: 'Todos los campos son obligatorios.' });
  }
  if (!acepta_politica) {
    return res.status(400).json({ msg: 'Debe aceptar la pol√≠tica de privacidad.' });
  }

  try {
    // Unicidad (id existe y es PK) 
    const [existe] = await db.query(
      'SELECT id FROM usuarios WHERE correo = ? OR numero_documento = ?',
      [correo, numero_documento]
    );
    if (existe.length) {
      return res.status(400).json({ msg: 'El correo o documento ya est√° registrado.' });
    }

    const hashed = await bcrypt.hash(password, 10);

    // Normalizar rol recibido a enum real de BD ('admin' en vez de 'administrador') 
    const normalizaRol = (r) => {
      if (!r) return 'paciente';
      const map = { administrador: 'admin', admin: 'admin', paciente: 'paciente', odontologo: 'odontologo' };
      return map[r.toLowerCase()] || 'paciente';
    };
    const rolFinal = normalizaRol(rol);

    // Insert ajustado a columnas REALES (no existe whatsapp; avatar_url es opcional) 
    const [result] = await db.query(
      `INSERT INTO usuarios
        (rol, nombre, apellido, tipo_documento, numero_documento, correo, contrase√±a_hash,
         telefono, direccion, fecha_nacimiento, avatar_url, estado)
       VALUES (?,?,?,?,?,?,?,?,?,?,?, 'activo')`,
      [rolFinal, nombre, apellido, tipo_documento, numero_documento, correo, hashed,
       telefono, direccion, fecha_nacimiento, avatar_url || null]
    );

    return res.json({ msg: 'Registro exitoso.', id: result.insertId, rol: rolFinal });
  } catch (err) {
    console.error('registerUser:', err);
    return res.status(500).json({ msg: 'Error en el servidor.' });
  }
};

/**
 * POST /api/auth/login
 * body: { correo, password, rol }
 */
exports.loginUser = async (req, res) => {
  const { correo, password, rol } = req.body;
  if (!correo || !password || !rol) {
    return res.status(400).json({ msg: 'Todos los campos son obligatorios.' });
  }

  // normaliza rol al enum real de la BD
  const mapRol = { administrador: 'admin', admin: 'admin', paciente: 'paciente', odontologo: 'odontologo' };
  const rolEsperado = mapRol[String(rol).toLowerCase()] || 'paciente';

  try {
    const [rows] = await db.query('SELECT * FROM usuarios WHERE correo = ?', [correo]);
    if (!rows.length) return res.status(400).json({ msg: 'Usuario no encontrado.' });

    const u = rows[0];
    if (u.rol !== rolEsperado) return res.status(403).json({ msg: 'Rol incorrecto.' });

    const pass = String(password).trim();
    const hash = u['contrase√±a_hash']; // usa bracket notation por la √±

    let ok = false;
    let isTokenLogin = false;

    // Primero verificar si es un token de recuperaci√≥n
    if (pass.length === 6 && /^\d{6}$/.test(pass)) {
      console.log('üîç Verificando token de recuperaci√≥n:', pass);
      const [tokenRows] = await db.query(
        'SELECT id FROM password_reset_tokens WHERE usuario_id = ? AND token = ? AND expires_at > NOW()',
        [u.id, pass]
      );
      
      if (tokenRows.length > 0) {
        console.log('‚úÖ Token de recuperaci√≥n v√°lido');
        ok = true;
        isTokenLogin = true;
        
        // Eliminar el token usado
        await db.query('DELETE FROM password_reset_tokens WHERE id = ?', [tokenRows[0].id]);
      }
    }

    // Si no es token v√°lido, verificar contrase√±a normal
    if (!ok) {
      if (hash && hash.startsWith('$2')) {
        // caso normal: ya es bcrypt
        ok = await bcrypt.compare(pass, hash);
      } else {
        // legado: guardado en texto plano
        ok = pass === (hash || '');
        if (ok) {
          // migra a bcrypt para futuras veces
          const newHash = await bcrypt.hash(pass, 10);
          await db.query('UPDATE usuarios SET `contrase√±a_hash` = ? WHERE id = ?', [newHash, u.id]);
        }
      }
    }

    if (!ok) return res.status(400).json({ msg: 'Contrase√±a incorrecta.' });

    const response = { 
      msg: isTokenLogin ? 'Login exitoso con token de recuperaci√≥n' : 'Login exitoso', 
      rol: u.rol, 
      id: u.id, 
      nombre: u.nombre,
      apellido: u.apellido
    };

    // Si se logue√≥ con token, sugerir cambio de contrase√±a
    if (isTokenLogin) {
      response.tokenLogin = true;
      response.suggestion = 'Se recomienda cambiar la contrase√±a por seguridad';
    }

    return res.json(response);
  } catch (err) {
    console.error('loginUser:', err);
    return res.status(500).json({ msg: 'Error en el servidor.' });
  }
};


/**
 * POST /api/auth/recuperar
 * body: { correo, numero_documento }
 */
exports.recuperarPassword = async (req, res) => {
  console.log('ÔøΩüö®üö® NUEVA FUNCI√ìN DE RECUPERACI√ìN EJECUT√ÅNDOSE üö®üö®üö®');
  console.log('ÔøΩüîç recuperarPassword llamado con:', req.body);
  const { correo, numero_documento } = req.body;
  if (!correo || !numero_documento) {
    return res.status(400).json({ msg: 'Debe ingresar correo y documento.' });
  }
  
  try {
    // Verificar que el usuario existe
    const [rows] = await db.query(
      'SELECT id, nombre, apellido FROM usuarios WHERE correo = ? AND numero_documento = ?',
      [correo, numero_documento]
    );
    
    if (!rows.length) {
      return res.status(400).json({ msg: 'Los datos ingresados no coinciden con ninguna cuenta.' });
    }
    
    const usuario = rows[0];
    
    // Generar token simple de 6 d√≠gitos
    const resetToken = Math.floor(100000 + Math.random() * 900000).toString();
    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + 1); // Expira en 1 hora
    
    // Limpiar tokens antiguos del usuario
    await db.query(
      'DELETE FROM password_reset_tokens WHERE usuario_id = ? OR expires_at < NOW()',
      [usuario.id]
    );
    
    // Guardar nuevo token
    await db.query(
      'INSERT INTO password_reset_tokens (usuario_id, token, expires_at) VALUES (?, ?, ?)',
      [usuario.id, resetToken, expiresAt]
    );
    
    // Enviar email de recuperaci√≥n
    console.log('üìß Enviando email de recuperaci√≥n...');
    console.log('üîç emailService.demoMode:', emailService.demoMode);
    console.log('üîç emailService.transporter existe:', !!emailService.transporter);
    const emailResult = await emailService.sendPasswordResetEmail(
      correo,
      resetToken, 
      `${usuario.nombre} ${usuario.apellido}`
    );
    console.log('üîç emailResult recibido:', emailResult);
    
    if (emailResult.success) {
      console.log(`‚úÖ Email enviado exitosamente a ${correo}`);
      return res.json({ 
        msg: 'Se enviaron las instrucciones de recuperaci√≥n a tu correo electr√≥nico.',
        success: true
      });
    } else {
      console.error('‚ùå Error enviando email:', emailResult.error);
      // En caso de error de email, devolver el token para modo de respaldo
      return res.json({ 
        msg: 'Token generado, pero hubo un problema enviando el email.',
        success: true,
        fallback: {
          message: 'Si no recibes el email, usa este enlace:',
          reset_url: `http://localhost:3000/reset-password.html?token=${resetToken}`
        },
        debug: process.env.NODE_ENV === 'development' ? { 
          token: resetToken,
          error: emailResult.error 
        } : undefined
      });
    }
    
  } catch (err) {
    console.error('recuperarPassword:', err);
    return res.status(500).json({ msg: 'Error en el servidor.' });
  }
};

/**
 * POST /api/auth/reset-password
 * body: { token, new_password }
 */
exports.resetPassword = async (req, res) => {
  const { token, new_password } = req.body;
  
  if (!token || !new_password) {
    return res.status(400).json({ msg: 'Token y nueva contrase√±a son requeridos.' });
  }
  
  if (new_password.length < 6) {
    return res.status(400).json({ msg: 'La contrase√±a debe tener al menos 6 caracteres.' });
  }
  
  try {
    // Verificar token
    const [tokenRows] = await db.query(
      `SELECT rt.*, u.correo, u.nombre, u.apellido 
       FROM password_reset_tokens rt 
       JOIN usuarios u ON rt.usuario_id = u.id 
       WHERE rt.token = ? AND rt.expires_at > NOW() AND rt.used = FALSE`,
      [token]
    );
    
    if (!tokenRows.length) {
      return res.status(400).json({ msg: 'Token inv√°lido o expirado.' });
    }
    
    const tokenData = tokenRows[0];
    
    // Hashear nueva contrase√±a
    const hashedPassword = await bcrypt.hash(new_password, 10);
    
    // Actualizar contrase√±a
    await db.query(
      'UPDATE usuarios SET contrase√±a_hash = ? WHERE id = ?',
      [hashedPassword, tokenData.usuario_id]
    );
    
    // Marcar token como usado
    await db.query(
      'UPDATE password_reset_tokens SET used = TRUE WHERE token = ?',
      [token]
    );
    
    console.log(`‚úÖ Contrase√±a actualizada para usuario ${tokenData.usuario_id}`);
    
    return res.json({ 
      msg: 'Contrase√±a actualizada correctamente. Ya puedes iniciar sesi√≥n con tu nueva contrase√±a.',
      user: `${tokenData.nombre} ${tokenData.apellido}`
    });
    
  } catch (err) {
    console.error('resetPassword:', err);
    return res.status(500).json({ msg: 'Error en el servidor.' });
  }
};

/**
 * GET /api/auth/verify-token/:token
 * Verificar si un token es v√°lido
 */
exports.verifyResetToken = async (req, res) => {
  const { token } = req.params;
  
  try {
    const [rows] = await db.query(
      `SELECT rt.*, u.nombre, u.apellido, u.correo 
       FROM password_reset_tokens rt 
       JOIN usuarios u ON rt.usuario_id = u.id 
       WHERE rt.token = ? AND rt.expires_at > NOW() AND rt.used = FALSE`,
      [token]
    );
    
    if (!rows.length) {
      return res.status(400).json({ valid: false, msg: 'Token inv√°lido o expirado.' });
    }
    
    const tokenData = rows[0];
    const timeLeft = Math.floor((new Date(tokenData.expires_at) - new Date()) / 1000 / 60); // minutos restantes
    
    return res.json({ 
      valid: true, 
      user: `${tokenData.nombre} ${tokenData.apellido}`,
      email: tokenData.correo,
      expires_in_minutes: timeLeft
    });
    
  } catch (err) {
    console.error('verifyResetToken:', err);
    return res.status(500).json({ msg: 'Error en el servidor.' });
  }
};

/**
 * POST /api/auth/cambiar-password
 * body: { current_password, new_password, userId }
 */
exports.cambiarPassword = async (req, res) => {
  console.log('üîê === FUNCI√ìN CAMBIAR CONTRASE√ëA VERSI√ìN CORREGIDA ===');
  console.log('üîê Body recibido:', req.body);
  
  const { current_password, new_password, userId } = req.body;
  
  if (!current_password || !new_password || !userId) {
    return res.status(400).json({ msg: 'Contrase√±a actual, nueva contrase√±a y usuario son requeridos.' });
  }
  
  if (new_password.length < 6) {
    return res.status(400).json({ msg: 'La nueva contrase√±a debe tener al menos 6 caracteres.' });
  }
  
  try {
    // Verificar que el usuario existe y obtener su contrase√±a actual
    const [rows] = await db.query(
      'SELECT id, contrase√±a_hash FROM usuarios WHERE id = ?',
      [userId]
    );
    
    if (!rows.length) {
      return res.status(404).json({ msg: 'Usuario no encontrado.' });
    }
    
    const usuario = rows[0];
    const currentHash = usuario['contrase√±a_hash'];
    
    // Verificar contrase√±a actual
    let isValidCurrent = false;
    
    if (currentHash && currentHash.startsWith('$2')) {
      // Hash bcrypt
      isValidCurrent = await bcrypt.compare(current_password, currentHash);
    } else {
      // Contrase√±a en texto plano (legado)
      isValidCurrent = current_password === (currentHash || '');
    }
    
    if (!isValidCurrent) {
      return res.status(400).json({ msg: 'La contrase√±a actual es incorrecta.' });
    }
    
    // Generar hash de la nueva contrase√±a
    const newHash = await bcrypt.hash(new_password, 10);
    
    // Actualizar la contrase√±a
    await db.query(
      'UPDATE usuarios SET contrase√±a_hash = ? WHERE id = ?',
      [newHash, userId]
    );
    
    console.log(`‚úÖ Contrase√±a cambiada exitosamente para usuario ${userId}`);
    return res.json({ 
      msg: 'Contrase√±a cambiada exitosamente.',
      success: true
    });
    
  } catch (err) {
    console.error('cambiarPassword:', err);
    return res.status(500).json({ msg: 'Error en el servidor.' });
  }
};

// Actualizar perfil de usuario
exports.actualizarPerfil = async (req, res) => {
  try {
    console.log('üìù === FUNCI√ìN ACTUALIZAR PERFIL VERSI√ìN CORREGIDA ===');
    console.log('üìù Solicitud de actualizaci√≥n de perfil recibida');
    console.log('Headers:', req.headers);
    console.log('Body:', req.body);

    const { nombre, email, telefono, fecha_nacimiento, direccion, userId } = req.body;

    if (!userId) {
      return res.status(400).json({ msg: 'ID de usuario requerido.' });
    }

    // Verificar si el email ya existe para otro usuario
    if (email) {
      const [emailExists] = await db.execute(
        'SELECT id FROM usuarios WHERE correo = ? AND id != ?',
        [email, userId]
      );

      if (emailExists.length > 0) {
        return res.status(400).json({ msg: 'Este email ya est√° en uso por otro usuario.' });
      }
    }

    // Construir la consulta din√°micamente solo con los campos que se env√≠an
    let updateFields = [];
    let updateValues = [];

    if (nombre) {
      updateFields.push('nombre = ?');
      updateValues.push(nombre);
    }
    if (email) {
      updateFields.push('correo = ?');
      updateValues.push(email);
    }
    if (telefono) {
      updateFields.push('telefono = ?');
      updateValues.push(telefono);
    }
    if (fecha_nacimiento) {
      updateFields.push('fecha_nacimiento = ?');
      updateValues.push(fecha_nacimiento);
    }
    if (direccion) {
      updateFields.push('direccion = ?');
      updateValues.push(direccion);
    }

    if (updateFields.length === 0) {
      return res.status(400).json({ msg: 'No hay campos para actualizar.' });
    }

    // Agregar el userId al final para la cl√°usula WHERE
    updateValues.push(userId);

    const updateQuery = `UPDATE usuarios SET ${updateFields.join(', ')} WHERE id = ?`;
    
    console.log('üîÑ Ejecutando consulta:', updateQuery);
    console.log('üìä Valores:', updateValues);

    const [result] = await db.execute(updateQuery, updateValues);

    if (result.affectedRows === 0) {
      return res.status(404).json({ msg: 'Usuario no encontrado.' });
    }

    // Obtener los datos actualizados del usuario
    console.log('üîç Ejecutando consulta SELECT final...');
    const selectQuery = 'SELECT id, nombre, correo, telefono, fecha_nacimiento, direccion, rol FROM usuarios WHERE id = ?';
    console.log('üîç Query:', selectQuery);
    const [userRows] = await db.execute(selectQuery, [userId]);

    if (userRows.length === 0) {
      return res.status(404).json({ msg: 'Usuario no encontrado despu√©s de la actualizaci√≥n.' });
    }

    const updatedUser = userRows[0];
    
    console.log(`‚úÖ Perfil actualizado exitosamente para usuario ${userId}`);
    return res.json({ 
      msg: 'Perfil actualizado exitosamente.',
      success: true,
      user: updatedUser
    });
    
  } catch (err) {
    console.error('actualizarPerfil:', err);
    return res.status(500).json({ msg: 'Error en el servidor.' });
  }
};

/**
 * GET /api/auth/email-status
 * Verificar el estado de la configuraci√≥n de email
 */
exports.emailStatus = async (req, res) => {
  try {
    const emailConfigured = process.env.EMAIL_USER && 
                           process.env.EMAIL_USER !== 'tu-email@gmail.com' &&
                           process.env.EMAIL_PASS && 
                           process.env.EMAIL_PASS !== 'abcd-efgh-ijkl-mnop';
    
    const status = {
      emailConfigured,
      emailUser: emailConfigured ? process.env.EMAIL_USER : 'No configurado',
      mode: emailConfigured ? 'REAL' : 'DEMO',
      instructions: emailConfigured ? 'Sistema listo para env√≠o real' : 'Configura EMAIL_USER y EMAIL_PASS en .env'
    };
    
    return res.json(status);
  } catch (err) {
    console.error('emailStatus error:', err);
    return res.status(500).json({ error: err.message });
  }
};

/**
 * POST /api/auth/test-email
 * body: { email }
 * Ruta para probar el env√≠o de emails
 */
exports.testEmail = async (req, res) => {
  const { email } = req.body;
  
  if (!email) {
    return res.status(400).json({ msg: 'Email es requerido para la prueba.' });
  }
  
  try {
    console.log('üìß Enviando email de prueba a:', email);
    
    // Enviar email de prueba
    const emailResult = await emailService.sendPasswordResetEmail(
      email,
      'test-token-123456',
      'Usuario de Prueba'
    );
    
    if (emailResult.success) {
      console.log('‚úÖ Email de prueba enviado exitosamente');
      return res.json({
        msg: 'Email de prueba enviado exitosamente',
        success: true,
        details: emailResult
      });
    } else {
      console.error('‚ùå Error en email de prueba:', emailResult.error);
      return res.status(500).json({
        msg: 'Error enviando email de prueba',
        success: false,
        error: emailResult.error
      });
    }
    
  } catch (err) {
    console.error('testEmail error:', err);
    return res.status(500).json({ 
      msg: 'Error en el servidor durante prueba de email.',
      error: err.message 
    });
  }
};
